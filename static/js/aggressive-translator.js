// Aggressive Translation System - Translates EVERYTHING
console.log('ЁЯМР Loading Aggressive Translator...');

// Comprehensive translation dictionary
const aggressiveTranslations = {
    // Navigation & UI
    'Login': 'рд▓реЙрдЧрд┐рди',
    'Register': 'рдкрдВрдЬреАрдХрд░рдг',
    'English': 'рдЕрдВрдЧреНрд░реЗрдЬреА',
    'рд╣рд┐рдВрджреА': 'рд╣рд┐рдВрджреА',
    'Dashboard': 'рдбреИрд╢рдмреЛрд░реНрдб',
    'Profile': 'рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓',
    'Logout': 'рд▓реЙрдЧрдЖрдЙрдЯ',
    
    // Headers and titles
    'Drone Application & Research Center': 'рдбреНрд░реЛрди рдЕрдиреБрдкреНрд░рдпреЛрдЧ рдФрд░ рдЕрдиреБрд╕рдВрдзрд╛рди рдХреЗрдВрджреНрд░',
    'Uttarakhand Space Application Center': 'рдЙрддреНрддрд░рд╛рдЦрдВрдб рдЕрдВрддрд░рд┐рдХреНрд╖ рдЕрдиреБрдкреНрд░рдпреЛрдЧ рдХреЗрдВрджреНрд░',
    'Drone Maps': 'рдбреНрд░реЛрди рдореИрдкреНрд╕',
    'Clear Quality Maps': 'рд╕реНрдкрд╖реНрдЯ рдЧреБрдгрд╡рддреНрддрд╛ рдорд╛рдирдЪрд┐рддреНрд░',
    'Create Account': 'рдЦрд╛рддрд╛ рдмрдирд╛рдПрдВ',
    'Join the Drone Mapping Community': 'рдбреНрд░реЛрди рдореИрдкрд┐рдВрдЧ рд╕рдореБрджрд╛рдп рдореЗрдВ рд╢рд╛рдорд┐рд▓ рд╣реЛрдВ',
    
    // Form labels
    'Full Name': 'рдкреВрд░рд╛ рдирд╛рдо',
    'Username': 'рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛ рдирд╛рдо',
    'Username/Email': 'рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛ рдирд╛рдо/рдИрдореЗрд▓',
    'Email Address': 'рдИрдореЗрд▓ рдкрддрд╛',
    'Password': 'рдкрд╛рд╕рд╡рд░реНрдб',
    'Confirm Password': 'рдкрд╛рд╕рд╡рд░реНрдб рдХреА рдкреБрд╖реНрдЯрд┐ рдХрд░реЗрдВ',
    'Phone Number': 'рдлреЛрди рдирдВрдмрд░',
    'Organization': 'рд╕рдВрдЧрдарди',
    'Security Code': 'рд╕реБрд░рдХреНрд╖рд╛ рдХреЛрдб',
    
    // Placeholders
    'Enter your full name': 'рдЕрдкрдирд╛ рдкреВрд░рд╛ рдирд╛рдо рджрд░реНрдЬ рдХрд░реЗрдВ',
    'Choose a username': 'рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛ рдирд╛рдо рдЪреБрдиреЗрдВ',
    'Enter your email address': 'рдЕрдкрдирд╛ рдИрдореЗрд▓ рдкрддрд╛ рджрд░реНрдЬ рдХрд░реЗрдВ',
    'Enter username or email': 'рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛ рдирд╛рдо рдпрд╛ рдИрдореЗрд▓ рджрд░реНрдЬ рдХрд░реЗрдВ',
    'Enter password': 'рдкрд╛рд╕рд╡рд░реНрдб рджрд░реНрдЬ рдХрд░реЗрдВ',
    'Create a password': 'рдкрд╛рд╕рд╡рд░реНрдб рдмрдирд╛рдПрдВ',
    'Confirm your password': 'рдЕрдкрдирд╛ рдкрд╛рд╕рд╡рд░реНрдб рдкреБрд╖реНрдЯрд┐ рдХрд░реЗрдВ',
    'Enter the code above': 'рдКрдкрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рдХреЛрдб рджрд░реНрдЬ рдХрд░реЗрдВ',
    'Your organization (optional)': 'рдЖрдкрдХрд╛ рд╕рдВрдЧрдарди (рд╡реИрдХрд▓реНрдкрд┐рдХ)',
    'Your phone number (optional)': 'рдЖрдкрдХрд╛ рдлреЛрди рдирдВрдмрд░ (рд╡реИрдХрд▓реНрдкрд┐рдХ)',
    
    // Buttons and actions
    'Save': 'рд╕рд╣реЗрдЬреЗрдВ',
    'Cancel': 'рд░рджреНрдж рдХрд░реЗрдВ',
    'Update': 'рдЕрдкрдбреЗрдЯ',
    'Delete': 'рд╣рдЯрд╛рдПрдВ',
    'Edit': 'рд╕рдВрдкрд╛рджрд┐рдд рдХрд░реЗрдВ',
    'Submit': 'рдЬрдорд╛ рдХрд░реЗрдВ',
    'Reset': 'рд░реАрд╕реЗрдЯ',
    
    // Links and navigation
    "Don't have an account?": 'рдЦрд╛рддрд╛ рдирд╣реАрдВ рд╣реИ?',
    'Register here': 'рдпрд╣рд╛рдБ рдкрдВрдЬреАрдХрд░рдг рдХрд░реЗрдВ',
    'Already have an account?': 'рдкрд╣рд▓реЗ рд╕реЗ рдЦрд╛рддрд╛ рд╣реИ?',
    'Sign in here': 'рдпрд╣рд╛рдБ рд╕рд╛рдЗрди рдЗрди рдХрд░реЗрдВ',
    
    // Legal and policy
    'I agree to the': 'рдореИрдВ рд╕рд╣рдордд рд╣реВрдВ',
    'Terms of Service': 'рд╕реЗрд╡рд╛ рдХреА рд╢рд░реНрддреЗрдВ',
    'and': 'рдФрд░',
    'Privacy Policy': 'рдЧреЛрдкрдиреАрдпрддрд╛ рдиреАрддрд┐',
    'I agree to the Terms of Service and Privacy Policy': 'рдореИрдВ рд╕реЗрд╡рд╛ рдХреА рд╢рд░реНрддреЛрдВ рдФрд░ рдЧреЛрдкрдиреАрдпрддрд╛ рдиреАрддрд┐ рд╕реЗ рд╕рд╣рдордд рд╣реВрдВ',
    
    // Messages and notifications
    'Note: New registrations require admin approval': 'рдиреЛрдЯ: рдирдП рдкрдВрдЬреАрдХрд░рдг рдХреЗ рд▓рд┐рдП рд╡реНрдпрд╡рд╕реНрдерд╛рдкрдХ рдХреА рдЕрдиреБрдорддрд┐ рдЖрд╡рд╢реНрдпрдХ рд╣реИ',
    'Account registration requires admin approval. You will be notified once your account is approved.': 'рдЦрд╛рддрд╛ рдкрдВрдЬреАрдХрд░рдг рдХреЗ рд▓рд┐рдП рд╡реНрдпрд╡рд╕реНрдерд╛рдкрдХ рдХреА рдЕрдиреБрдорддрд┐ рдЖрд╡рд╢реНрдпрдХ рд╣реИред рдЖрдкрдХреЗ рдЦрд╛рддреЗ рдХреА рдЕрдиреБрдорддрд┐ рдорд┐рд▓рдиреЗ рдкрд░ рдЖрдкрдХреЛ рд╕реВрдЪрд┐рдд рдХрд┐рдпрд╛ рдЬрд╛рдПрдЧрд╛ред',
    
    // Profile page
    'Personal Info': 'рд╡реНрдпрдХреНрддрд┐рдЧрдд рдЬрд╛рдирдХрд╛рд░реА',
    'Security': 'рд╕реБрд░рдХреНрд╖рд╛',
    'App Settings': 'рдРрдк рд╕реЗрдЯрд┐рдВрдЧреНрд╕',
    'Activity Log': 'рдЧрддрд┐рд╡рд┐рдзрд┐ рд▓реЙрдЧ',
    'Personal Information': 'рд╡реНрдпрдХреНрддрд┐рдЧрдд рдЬрд╛рдирдХрд╛рд░реА',
    'Account Status': 'рдЦрд╛рддрд╛ рд╕реНрдерд┐рддрд┐',
    'Role': 'рднреВрдорд┐рдХрд╛',
    'Member Since': 'рд╕рджрд╕реНрдп рдмрдирдиреЗ рдХреА рддрд╛рд░реАрдЦ',
    'Last Login': 'рдЕрдВрддрд┐рдо рд▓реЙрдЧрд┐рди',
    'Never': 'рдХрднреА рдирд╣реАрдВ',
    
    // Status and states
    'Active': 'рд╕рдХреНрд░рд┐рдп',
    'Inactive': 'рдирд┐рд╖реНрдХреНрд░рд┐рдп',
    'Pending': 'рд▓рдВрдмрд┐рдд',
    'Approved': 'рдЕрдиреБрдореЛрджрд┐рдд',
    'Suspended': 'рдирд┐рд▓рдВрдмрд┐рдд',
    'Admin': 'рд╡реНрдпрд╡рд╕реНрдерд╛рдкрдХ',
    'User': 'рдЙрдкрдпреЛрдЧрдХрд░реНрддрд╛',
    'Analyst': 'рд╡рд┐рд╢реНрд▓реЗрд╖рдХ',

    // Map and navigation
    'Map View': 'рдорд╛рдирдЪрд┐рддреНрд░ рджреГрд╢реНрдп',
    'Projects': 'рдкрд░рд┐рдпреЛрдЬрдирд╛рдПрдВ',
    'Select Base Map': 'рдЖрдзрд╛рд░ рдорд╛рдирдЪрд┐рддреНрд░ рдЪреБрдиреЗрдВ',
    'Base Map:': 'рдЖрдзрд╛рд░ рдорд╛рдирдЪрд┐рддреНрд░:',
    'Base Map': 'рдЖрдзрд╛рд░ рдорд╛рдирдЪрд┐рддреНрд░',
    'OpenStreetMap': 'рдУрдкрдирд╕реНрдЯреНрд░реАрдЯрдореИрдк',
    'Welcome, admin': 'рд╕реНрд╡рд╛рдЧрдд, рд╡реНрдпрд╡рд╕реНрдерд╛рдкрдХ',
    'Welcome': 'рд╕реНрд╡рд╛рдЧрдд',
    'admin': 'рд╡реНрдпрд╡рд╕реНрдерд╛рдкрдХ',

    // Search functionality
    'Search Project': 'рдкрд░рд┐рдпреЛрдЬрдирд╛ рдЦреЛрдЬреЗрдВ',
    'No projects found for': 'рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдкрд░рд┐рдпреЛрдЬрдирд╛ рдирд╣реАрдВ рдорд┐рд▓реА',
    'Try a different search term': 'рдПрдХ рдЕрд▓рдЧ рдЦреЛрдЬ рд╢рдмреНрдж рдЖрдЬрд╝рдорд╛рдПрдВ',

    // Additional translations for login/register
    "Don't have an account?": 'рдЦрд╛рддрд╛ рдирд╣реАрдВ рд╣реИ?',
    'Register here': 'рдпрд╣рд╛рдБ рдкрдВрдЬреАрдХрд░рдг рдХрд░реЗрдВ',
    'Note: New registrations require admin approval': 'рдиреЛрдЯ: рдирдП рдкрдВрдЬреАрдХрд░рдг рдХреЗ рд▓рд┐рдП рд╡реНрдпрд╡рд╕реНрдерд╛рдкрдХ рдХреА рдЕрдиреБрдорддрд┐ рдЖрд╡рд╢реНрдпрдХ рд╣реИ',
    'Already have an account?': 'рдкрд╣рд▓реЗ рд╕реЗ рдЦрд╛рддрд╛ рд╣реИ?',
    'Login here': 'рдпрд╣рд╛рдБ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВ',

    // Dynamic project names - basic fallback translations
    // Note: These will be supplemented by dynamic translation API
};

// Current language state
let currentLang = localStorage.getItem('language') || 'en';

// Store original content
const originalTexts = new WeakMap();

// Dynamic translation cache
const dynamicTranslationCache = new Map();

// Simple translation rules for dynamic content
const translationRules = {
    // Common English words to Hindi
    'test': 'рдкрд░реАрдХреНрд╖рдг',
    'new': 'рдирдпрд╛',
    'project': 'рдкрд░рд┐рдпреЛрдЬрдирд╛',
    'data': 'рдбреЗрдЯрд╛',
    'map': 'рдорд╛рдирдЪрд┐рддреНрд░',
    'survey': 'рд╕рд░реНрд╡реЗрдХреНрд╖рдг',
    'area': 'рдХреНрд╖реЗрддреНрд░',
    'zone': 'рдХреНрд╖реЗрддреНрд░',
    'region': 'рдХреНрд╖реЗрддреНрд░',
    'district': 'рдЬрд┐рд▓рд╛',
    'village': 'рдЧрд╛рдВрд╡',
    'city': 'рд╢рд╣рд░',
    'town': 'рдХрд╕реНрдмрд╛',
    'river': 'рдирджреА',
    'mountain': 'рдкрд░реНрд╡рдд',
    'forest': 'рд╡рди',
    'road': 'рд╕рдбрд╝рдХ',
    'bridge': 'рдкреБрд▓',
    'dam': 'рдмрд╛рдВрдз',
    'lake': 'рдЭреАрд▓',
    'valley': 'рдШрд╛рдЯреА',
    'hill': 'рдкрд╣рд╛рдбрд╝реА',
    'colony': 'рдХреЙрд▓реЛрдиреА',
    'block': 'рдмреНрд▓реЙрдХ',
    'sector': 'рд╕реЗрдХреНрдЯрд░',
    'phase': 'рдЪрд░рдг',
    'development': 'рд╡рд┐рдХрд╛рд╕',
    'construction': 'рдирд┐рд░реНрдорд╛рдг',
    'infrastructure': 'рдЕрд╡рд╕рдВрд░рдЪрдирд╛',
    'residential': 'рдЖрд╡рд╛рд╕реАрдп',
    'commercial': 'рд╡реНрдпрд╛рд╡рд╕рд╛рдпрд┐рдХ',
    'industrial': 'рдФрджреНрдпреЛрдЧрд┐рдХ',
    'agricultural': 'рдХреГрд╖рд┐',
    'boundary': 'рд╕реАрдорд╛',
    'border': 'рд╕реАрдорд╛',
    'limit': 'рд╕реАрдорд╛'
};

// Dynamic translation function with multiple strategies
function translateText(text) {
    if (!text || typeof text !== 'string') return text;

    const trimmedText = text.trim();
    if (!trimmedText) return text;

    // Check cache first
    if (dynamicTranslationCache.has(trimmedText.toLowerCase())) {
        return dynamicTranslationCache.get(trimmedText.toLowerCase());
    }

    // Strategy 1: Direct lookup in static dictionary
    if (aggressiveTranslations[trimmedText]) {
        return aggressiveTranslations[trimmedText];
    }

    // Strategy 2: Case-insensitive lookup in static dictionary
    for (const [key, value] of Object.entries(aggressiveTranslations)) {
        if (key.toLowerCase() === trimmedText.toLowerCase()) {
            return value;
        }
    }

    // Strategy 3: Dynamic word-by-word translation
    const dynamicTranslation = translateDynamically(trimmedText);
    if (dynamicTranslation !== trimmedText) {
        // Cache the result
        dynamicTranslationCache.set(trimmedText.toLowerCase(), dynamicTranslation);
        return dynamicTranslation;
    }

    // Strategy 4: Partial word matching (fallback)
    for (const [key, value] of Object.entries(aggressiveTranslations)) {
        if (trimmedText.includes(key) || key.includes(trimmedText)) {
            return value;
        }
    }

    return text;
}

// Dynamic translation using word rules and patterns
function translateDynamically(text) {
    const originalText = text;
    let translatedText = text;

    // Convert to lowercase for processing
    const lowerText = text.toLowerCase();

    // Strategy 1: Direct word lookup
    if (translationRules[lowerText]) {
        return translationRules[lowerText];
    }

    // Strategy 2: Word-by-word translation for compound terms
    const words = lowerText.split(/[\s_-]+/);
    if (words.length > 1) {
        const translatedWords = words.map(word => {
            // Remove numbers and special characters for translation
            const cleanWord = word.replace(/[0-9]/g, '').replace(/[^a-zA-Z]/g, '');
            if (cleanWord && translationRules[cleanWord]) {
                return translationRules[cleanWord];
            }
            return word; // Keep original if no translation found
        });

        // If any words were translated, return the result
        const result = translatedWords.join(' ');
        if (result !== lowerText) {
            return result;
        }
    }

    // Strategy 3: Pattern-based translation
    // Handle common patterns like "Name_Year", "Place_Type", etc.
    if (lowerText.includes('_')) {
        const parts = lowerText.split('_');
        const translatedParts = parts.map(part => {
            const cleanPart = part.replace(/[0-9]/g, '').replace(/[^a-zA-Z]/g, '');
            if (cleanPart && translationRules[cleanPart]) {
                return translationRules[cleanPart] + (part.match(/[0-9]+/) ? ' ' + part.match(/[0-9]+/)[0] : '');
            }
            return part;
        });

        const result = translatedParts.join(' ');
        if (result !== lowerText) {
            return result;
        }
    }

    // Strategy 4: Partial matching for known words
    for (const [englishWord, hindiWord] of Object.entries(translationRules)) {
        if (lowerText.includes(englishWord)) {
            translatedText = translatedText.replace(new RegExp(englishWord, 'gi'), hindiWord);
        }
    }

    return translatedText;
}

// Handle data-i18n attributes
function handleDataI18nAttributes() {
    console.log('ЁЯФД Processing data-i18n attributes...');

    // Define i18n translations
    const i18nTranslations = {
        'appTitle': 'рдбреНрд░реЛрди рдЕрдиреБрдкреНрд░рдпреЛрдЧ рдФрд░ рдЕрдиреБрд╕рдВрдзрд╛рди рдХреЗрдВрджреНрд░',
        'subTitle': 'рдЙрддреНрддрд░рд╛рдЦрдВрдб рдЕрдВрддрд░рд┐рдХреНрд╖ рдЕрдиреБрдкреНрд░рдпреЛрдЧ рдХреЗрдВрджреНрд░',
        'mapView': 'рдорд╛рдирдЪрд┐рддреНрд░ рджреГрд╢реНрдп',
        'dashboard': 'рдбреИрд╢рдмреЛрд░реНрдб',
        'profile': 'рдкреНрд░реЛрдлрд╝рд╛рдЗрд▓',
        'welcome': 'рд╕реНрд╡рд╛рдЧрдд',
        'logout': 'рд▓реЙрдЧрдЖрдЙрдЯ',
        'selectBaseMap': 'рдЖрдзрд╛рд░ рдорд╛рдирдЪрд┐рддреНрд░ рдЪреБрдиреЗрдВ',
        'geoserverProjects': 'рдкрд░рд┐рдпреЛрдЬрдирд╛рдПрдВ',
        'searchPlaceholder': 'рд╕реНрдерд╛рди рдЦреЛрдЬреЗрдВ',
        'searchProject': 'рдкрд░рд┐рдпреЛрдЬрдирд╛ рдЦреЛрдЬреЗрдВ'
    };

    let translatedCount = 0;

    // Handle data-i18n attributes
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        const translation = i18nTranslations[key];

        if (translation) {
            // Store original if not already stored
            if (!element.hasAttribute('data-original-text')) {
                element.setAttribute('data-original-text', element.textContent);
            }
            element.textContent = translation;
            translatedCount++;
        }
    });

    // Handle data-i18n-placeholder attributes
    document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
        const key = element.getAttribute('data-i18n-placeholder');
        const translation = i18nTranslations[key];

        if (translation) {
            // Store original if not already stored
            if (!element.hasAttribute('data-original-placeholder')) {
                element.setAttribute('data-original-placeholder', element.placeholder);
            }
            element.placeholder = translation;
            translatedCount++;
        }
    });

    console.log(`тЬЕ Processed ${translatedCount} data-i18n elements`);
}

// Restore data-i18n elements
function restoreDataI18nElements() {
    console.log('ЁЯФД Restoring data-i18n elements...');

    let restoredCount = 0;

    // Restore data-i18n elements
    document.querySelectorAll('[data-i18n]').forEach(element => {
        if (element.hasAttribute('data-original-text')) {
            element.textContent = element.getAttribute('data-original-text');
            element.removeAttribute('data-original-text');
            restoredCount++;
        }
    });

    // Restore data-i18n-placeholder elements
    document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
        if (element.hasAttribute('data-original-placeholder')) {
            element.placeholder = element.getAttribute('data-original-placeholder');
            element.removeAttribute('data-original-placeholder');
            restoredCount++;
        }
    });

    console.log(`тЬЕ Restored ${restoredCount} data-i18n elements`);
}

// Handle buttons and links with icons
function handleButtonWithIcon(element) {
    // Find text nodes that are not inside icon elements
    const textNodes = [];

    function findTextNodes(node) {
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
            // Check if this text node is not inside an icon
            let parent = node.parentElement;
            let isInsideIcon = false;
            while (parent && parent !== element) {
                if (parent.tagName === 'I' && parent.classList.contains('fas')) {
                    isInsideIcon = true;
                    break;
                }
                parent = parent.parentElement;
            }
            if (!isInsideIcon) {
                textNodes.push(node);
            }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            // Don't traverse into icon elements
            if (!(node.tagName === 'I' && node.classList.contains('fas'))) {
                node.childNodes.forEach(findTextNodes);
            }
        }
    }

    element.childNodes.forEach(findTextNodes);

    // Translate only the text nodes (not the icons)
    textNodes.forEach((textNode, index) => {
        const originalText = textNode.textContent.trim();
        if (originalText.length > 1) {
            const translation = translateText(originalText);

            if (translation !== originalText) {
                // Store original
                const dataAttr = `data-original-button-text-${index}`;
                if (!element.hasAttribute(dataAttr)) {
                    element.setAttribute(dataAttr, originalText);
                }
                textNode.textContent = ` ${translation}`;
                console.log(`тЬЕ Translated button text: "${originalText}" тЖТ "${translation}"`);
            }
        }
    });
}

// Restore buttons with icons
function restoreButtonsWithIcons() {
    document.querySelectorAll('button, a').forEach(element => {
        const buttonTextAttrs = Array.from(element.attributes).filter(attr =>
            attr.name.startsWith('data-original-button-text-')
        );

        if (buttonTextAttrs.length > 0) {
            // Find text nodes again
            const textNodes = [];

            function findTextNodes(node) {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                    let parent = node.parentElement;
                    let isInsideIcon = false;
                    while (parent && parent !== element) {
                        if (parent.tagName === 'I' && parent.classList.contains('fas')) {
                            isInsideIcon = true;
                            break;
                        }
                        parent = parent.parentElement;
                    }
                    if (!isInsideIcon) {
                        textNodes.push(node);
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    if (!(node.tagName === 'I' && node.classList.contains('fas'))) {
                        node.childNodes.forEach(findTextNodes);
                    }
                }
            }

            element.childNodes.forEach(findTextNodes);

            // Restore text nodes
            buttonTextAttrs.forEach((attr, index) => {
                const originalText = attr.value;
                if (textNodes[index]) {
                    textNodes[index].textContent = ` ${originalText}`;
                }
                element.removeAttribute(attr.name);
            });
        }
    });
}

// Aggressive translation - hits everything
function aggressiveTranslate() {
    console.log('ЁЯФД Starting aggressive translation...');

    // First handle data-i18n attributes
    handleDataI18nAttributes();

    // Get ALL elements
    const allElements = document.querySelectorAll('*');
    let translatedCount = 0;

    allElements.forEach(element => {
        // Skip script and style
        if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE') return;

        // Skip elements marked as non-translatable
        if (element.hasAttribute('data-no-translate')) return;

        // Skip notification elements
        if (element.classList.contains('language-notification')) return;

        // Special handling for buttons and links with icons
        if ((element.tagName === 'BUTTON' || element.tagName === 'A') && element.querySelector('i.fas')) {
            handleButtonWithIcon(element);
            return;
        }

        // Method 1: Translate text content if element has only text (no child elements)
        if (element.children.length === 0 && element.textContent.trim()) {
            const originalText = element.textContent.trim();

            // Skip if this looks like it contains icons or special characters
            if (originalText.includes('fas fa-') || originalText.includes('тЮбя╕П') || originalText.includes('ЁЯСд')) {
                return;
            }

            const translation = translateText(originalText);

            if (translation !== originalText) {
                // Store original in data attribute
                if (!element.hasAttribute('data-original-text')) {
                    element.setAttribute('data-original-text', originalText);
                }
                element.textContent = translation;
                translatedCount++;
                console.log(`тЬЕ Translated: "${originalText}" тЖТ "${translation}"`);
            }
        }

        // Method 2: Handle text nodes within elements that have children (like buttons with icons)
        if (element.childNodes.length > 0) {
            element.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                    const originalText = node.textContent.trim();

                    // Skip whitespace-only nodes or nodes that are just spaces
                    if (originalText.length < 2) return;

                    const translation = translateText(originalText);

                    if (translation !== originalText) {
                        // Store original in a unique data attribute for this specific text node
                        const parentElement = node.parentElement;
                        if (parentElement) {
                            const nodeIndex = Array.from(parentElement.childNodes).indexOf(node);
                            const dataAttr = `data-original-text-node-${nodeIndex}`;
                            if (!parentElement.hasAttribute(dataAttr)) {
                                parentElement.setAttribute(dataAttr, originalText);
                            }
                        }
                        node.textContent = ` ${translation}`;
                        translatedCount++;
                        console.log(`тЬЕ Translated text node: "${originalText}" тЖТ "${translation}"`);
                    }
                }
            });
        }
        
        // Translate placeholder
        if (element.placeholder) {
            const originalPlaceholder = element.placeholder;
            const translation = translateText(originalPlaceholder);

            if (translation !== originalPlaceholder) {
                // Store original in data attribute
                if (!element.hasAttribute('data-original-placeholder')) {
                    element.setAttribute('data-original-placeholder', originalPlaceholder);
                }
                element.placeholder = translation;
                translatedCount++;
                console.log(`тЬЕ Translated placeholder: "${originalPlaceholder}" тЖТ "${translation}"`);
            }
        }
        
        // Translate title
        if (element.title) {
            const originalTitle = element.title;
            const translation = translateText(originalTitle);

            if (translation !== originalTitle) {
                // Store original in data attribute
                if (!element.hasAttribute('data-original-title')) {
                    element.setAttribute('data-original-title', originalTitle);
                }
                element.title = translation;
                translatedCount++;
                console.log(`тЬЕ Translated title: "${originalTitle}" тЖТ "${translation}"`);
            }
        }
        
        // Translate value for buttons
        if (element.tagName === 'INPUT' && element.type === 'submit' && element.value) {
            const originalValue = element.value;
            const translation = translateText(originalValue);

            if (translation !== originalValue) {
                // Store original in data attribute
                if (!element.hasAttribute('data-original-value')) {
                    element.setAttribute('data-original-value', originalValue);
                }
                element.value = translation;
                translatedCount++;
                console.log(`тЬЕ Translated button value: "${originalValue}" тЖТ "${translation}"`);
            }
        }
    });
    
    console.log(`тЬЕ Aggressive translation completed! Translated ${translatedCount} elements.`);
}

// Restore everything
function restoreAllContent() {
    console.log('ЁЯФД Restoring all content...');

    // First restore data-i18n elements
    restoreDataI18nElements();

    // Restore buttons with icons
    restoreButtonsWithIcons();

    let restoredCount = 0;

    // Restore from data attributes
    document.querySelectorAll('*').forEach(element => {
        // Restore text content
        if (element.hasAttribute('data-original-text')) {
            element.textContent = element.getAttribute('data-original-text');
            element.removeAttribute('data-original-text');
            restoredCount++;
        }

        // Restore text nodes (handle indexed text nodes)
        const textNodeAttrs = Array.from(element.attributes).filter(attr =>
            attr.name.startsWith('data-original-text-node-')
        );

        textNodeAttrs.forEach(attr => {
            const nodeIndex = parseInt(attr.name.replace('data-original-text-node-', ''));
            const originalText = attr.value;
            const targetNode = element.childNodes[nodeIndex];

            if (targetNode && targetNode.nodeType === Node.TEXT_NODE) {
                targetNode.textContent = ` ${originalText}`;
                element.removeAttribute(attr.name);
                restoredCount++;
            }
        });

        // Restore placeholder
        if (element.hasAttribute('data-original-placeholder')) {
            element.placeholder = element.getAttribute('data-original-placeholder');
            element.removeAttribute('data-original-placeholder');
            restoredCount++;
        }

        // Restore title
        if (element.hasAttribute('data-original-title')) {
            element.title = element.getAttribute('data-original-title');
            element.removeAttribute('data-original-title');
            restoredCount++;
        }

        // Restore value
        if (element.hasAttribute('data-original-value')) {
            element.value = element.getAttribute('data-original-value');
            element.removeAttribute('data-original-value');
            restoredCount++;
        }
    });

    // Clear the original texts map
    originalTexts.clear();

    console.log(`тЬЕ Restoration completed! Restored ${restoredCount} elements.`);
}

// Set language
function setLanguage(lang) {
    console.log('ЁЯМР Setting language to:', lang);
    currentLang = lang;
    localStorage.setItem('language', lang);

    // Prepare notification message BEFORE any translation/restoration
    const notificationMessage = lang === 'hi' ?
        'рднрд╛рд╖рд╛ рд╣рд┐рдВрджреА рдореЗрдВ рдмрджрд▓ рдЧрдИ' :
        'Language changed to English';

    // Update button states
    const langEn = document.getElementById('lang-en');
    const langHi = document.getElementById('lang-hi');

    if (langEn && langHi) {
        if (lang === 'hi') {
            langHi.classList.add('active');
            langEn.classList.remove('active');

            // Show notification first, then translate
            console.log('ЁЯФФ Showing notification:', notificationMessage);
            showNotification(notificationMessage);

            // Multiple translation attempts to catch everything
            setTimeout(aggressiveTranslate, 100);
            setTimeout(aggressiveTranslate, 500);
            setTimeout(aggressiveTranslate, 1000);

            // Set up periodic re-translation for dynamic content
            const retranslateInterval = setInterval(() => {
                if (currentLang === 'hi') {
                    aggressiveTranslate();
                } else {
                    clearInterval(retranslateInterval);
                }
            }, 2000);

        } else {
            langEn.classList.add('active');
            langHi.classList.remove('active');

            // Show notification first, then restore
            console.log('ЁЯФФ Showing notification:', notificationMessage);
            showNotification(notificationMessage);

            // Restore content after showing notification
            setTimeout(restoreAllContent, 50);
        }
    }
}

// Show notification
function showNotification(message) {
    const notification = document.createElement('div');
    notification.className = 'language-notification'; // Add class for identification
    notification.setAttribute('data-no-translate', 'true'); // Mark as non-translatable
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-size: 14px;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transition: all 0.3s ease;
        transform: translateX(100%);
        opacity: 0;
        max-width: 300px;
        word-wrap: break-word;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);

    // Animate in
    setTimeout(() => {
        notification.style.transform = 'translateX(0)';
        notification.style.opacity = '1';
    }, 10);

    setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        notification.style.opacity = '0';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 300);
    }, 3000);
}

// Setup language switchers
function setupLanguageSwitchers() {
    const langEn = document.getElementById('lang-en');
    const langHi = document.getElementById('lang-hi');
    
    console.log('ЁЯФН Setting up language switchers...', { langEn, langHi });
    
    if (langEn && langHi) {
        langEn.addEventListener('click', () => setLanguage('en'));
        langHi.addEventListener('click', () => setLanguage('hi'));
        
        // Set initial state
        if (currentLang === 'hi') {
            langHi.classList.add('active');
            langEn.classList.remove('active');
            setTimeout(aggressiveTranslate, 200);
        } else {
            langEn.classList.add('active');
            langHi.classList.remove('active');
        }
        
        console.log('тЬЕ Language switchers set up');
    } else {
        console.warn('тЪая╕П Language switcher buttons not found');
    }
}

// Setup mutation observer to catch dynamic content
function setupMutationObserver() {
    const observer = new MutationObserver(function(mutations) {
        let shouldRetranslate = false;

        mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
                        shouldRetranslate = true;
                    }
                });
            }
        });

        if (shouldRetranslate && currentLang === 'hi') {
            console.log('ЁЯФД New content detected, re-translating...');
            setTimeout(aggressiveTranslate, 100);
        }
    });

    observer.observe(document.body, {
        childList: true,
        subtree: true,
        characterData: true
    });

    console.log('ЁЯСБя╕П Mutation observer set up');
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    console.log('ЁЯМР Aggressive Translator initializing...');
    setupLanguageSwitchers();
    setupMutationObserver();

    // If already in Hindi mode, translate immediately
    if (currentLang === 'hi') {
        setTimeout(aggressiveTranslate, 200);
    }

    console.log('тЬЕ Aggressive Translator ready!');
});

// Also initialize immediately if DOM is already loaded
if (document.readyState !== 'loading') {
    console.log('ЁЯМР DOM already loaded, initializing Aggressive Translator...');
    setupLanguageSwitchers();
    setupMutationObserver();

    // If already in Hindi mode, translate immediately
    if (currentLang === 'hi') {
        setTimeout(aggressiveTranslate, 200);
    }
}

console.log('тЬЕ Aggressive Translator script loaded');
